// lib/javari/modules/versioning.ts
// Module Factory Versioning
// Semver bump, changelog generation, SHA-256 artifact checksums
// 2026-02-19 — TASK-P1-001

import { createHash } from 'crypto';
import type { ModuleArtifacts, ModuleVersion } from './types';

// ── Semver Parsing ────────────────────────────────────────────────────────────

interface SemVer {
  major: number;
  minor: number;
  patch: number;
}

function parseSemVer(version: string): SemVer {
  const match = version.match(/^(\d+)\.(\d+)\.(\d+)/);
  if (!match) return { major: 1, minor: 0, patch: 0 };
  return {
    major: parseInt(match[1], 10),
    minor: parseInt(match[2], 10),
    patch: parseInt(match[3], 10),
  };
}

function formatSemVer(v: SemVer): string {
  return `${v.major}.${v.minor}.${v.patch}`;
}

export type BumpType = 'major' | 'minor' | 'patch';

export function bumpVersion(current: string, type: BumpType): string {
  const v = parseSemVer(current);
  switch (type) {
    case 'major':
      return formatSemVer({ major: v.major + 1, minor: 0, patch: 0 });
    case 'minor':
      return formatSemVer({ major: v.major, minor: v.minor + 1, patch: 0 });
    case 'patch':
      return formatSemVer({ major: v.major, minor: v.minor, patch: v.patch + 1 });
  }
}

// ── Checksum ──────────────────────────────────────────────────────────────────

export function computeChecksum(artifacts: ModuleArtifacts): string {
  const hash = createHash('sha256');

  const allFiles = [
    artifacts.uiPage,
    ...artifacts.uiComponents,
    ...artifacts.apiRoutes,
    artifacts.dbMigration,
    artifacts.registryEntry,
    artifacts.readme,
  ].filter((f): f is NonNullable<typeof f> => f != null);

  // Sort by path for deterministic hash
  allFiles.sort((a, b) => a.path.localeCompare(b.path));

  for (const file of allFiles) {
    hash.update(file.path);
    hash.update(file.content);
  }

  return hash.digest('hex');
}

// ── Changelog Generation ──────────────────────────────────────────────────────

export function generateChangelog(
  version: string,
  slug: string,
  artifacts: ModuleArtifacts,
  bumpType: BumpType
): string {
  const now = new Date().toISOString().split('T')[0];
  const fileList = [
    artifacts.uiPage,
    ...artifacts.uiComponents,
    ...artifacts.apiRoutes,
    artifacts.dbMigration,
    artifacts.registryEntry,
  ]
    .filter((f): f is NonNullable<typeof f> => f != null)
    .map((f) => `  - \`${f.path}\``)
    .join('\n');

  const bumpLabels: Record<BumpType, string> = {
    major: 'Breaking Change',
    minor: 'New Feature',
    patch: 'Bug Fix / Patch',
  };

  return [
    `## [${version}] — ${now}`,
    '',
    `**Type:** ${bumpLabels[bumpType]}  `,
    `**Module:** \`${slug}\`  `,
    `**Generator:** Javari Module Factory v2.0`,
    '',
    '### Files Generated',
    fileList,
    '',
    '### Notes',
    `- Generated by autonomous Javari Module Factory pipeline`,
    `- Artifacts validated before commit`,
    `- Module registered in Supabase javari_modules table`,
  ].join('\n');
}

// ── Determine Bump Type From Context ──────────────────────────────────────────

export function determineBumpType(
  previousVersion: string | null,
  isBreaking: boolean = false
): { version: string; bumpType: BumpType } {
  if (!previousVersion) {
    return { version: '1.0.0', bumpType: 'minor' };
  }

  const bumpType: BumpType = isBreaking ? 'major' : 'minor';
  return { version: bumpVersion(previousVersion, bumpType), bumpType };
}

// ── Main Version Builder ──────────────────────────────────────────────────────

export async function buildVersion(
  slug: string,
  artifacts: ModuleArtifacts,
  previousVersion: string | null = null,
  isBreaking: boolean = false
): Promise<ModuleVersion> {
  const { version, bumpType } = determineBumpType(previousVersion, isBreaking);
  const checksum = computeChecksum(artifacts);
  const changelog = generateChangelog(version, slug, artifacts, bumpType);

  return {
    semver: version,
    changelog,
    generatedAt: new Date().toISOString(),
    generatedBy: 'javari-module-factory@2.0',
    checksum,
  };
}

// ── Fetch Previous Version From Supabase ──────────────────────────────────────

export async function fetchPreviousVersion(slug: string): Promise<string | null> {
  const supaUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supaKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

  if (!supaUrl || !supaKey) return null;

  try {
    const res = await fetch(
      `${supaUrl}/rest/v1/javari_modules?slug=eq.${slug}&select=version&limit=1`,
      {
        headers: {
          apikey: supaKey,
          Authorization: `Bearer ${supaKey}`,
        },
      }
    );
    if (!res.ok) return null;
    const rows = await res.json() as { version: string }[];
    return rows[0]?.version ?? null;
  } catch {
    return null;
  }
}
