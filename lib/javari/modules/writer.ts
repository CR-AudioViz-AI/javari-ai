// lib/javari/modules/writer.ts
// Module Factory Writer
// Commits generated module files to GitHub using @octokit/rest
// Uses GITHUB_TOKEN from vault — branch: main, atomic multi-file commit
// 2026-02-19 — TASK-P1-001

import { Octokit } from '@octokit/rest';
import { vault } from '@/lib/javari/secrets/vault';
import type { ModuleArtifacts, ModuleRequest, CommitRecord, ModuleFile } from './types';

// ── Config ────────────────────────────────────────────────────────────────────

const REPO_OWNER = 'CR-AudioViz-AI';
const REPO_NAME = 'javari-ai';
const DEFAULT_BRANCH = 'main';

function getOctokit(): Octokit {
  const token = vault.get('github');
  if (!token) throw new Error('[Writer] GITHUB_TOKEN not found in vault');
  return new Octokit({ auth: token });
}

// ── Get current file SHA (for update vs create) ───────────────────────────────

async function getFileSHA(octokit: Octokit, path: string): Promise<string | undefined> {
  try {
    const res = await octokit.repos.getContent({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      path,
      ref: DEFAULT_BRANCH,
    });
    // Content API returns object with sha for files
    if (!Array.isArray(res.data) && 'sha' in res.data) {
      return res.data.sha;
    }
    return undefined;
  } catch {
    return undefined; // File doesn't exist yet — create it
  }
}

// ── Create tree entries for multi-file commit ─────────────────────────────────

async function buildTreeEntries(
  octokit: Octokit,
  files: ModuleFile[]
): Promise<{ path: string; mode: '100644'; type: 'blob'; sha: string }[]> {
  const entries: { path: string; mode: '100644'; type: 'blob'; sha: string }[] = [];

  for (const file of files) {
    // Create a blob for each file
    const blob = await octokit.git.createBlob({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      content: Buffer.from(file.content, 'utf8').toString('base64'),
      encoding: 'base64',
    });

    entries.push({
      path: file.path,
      mode: '100644',
      type: 'blob',
      sha: blob.data.sha,
    });
  }

  return entries;
}

// ── Collect all files from artifacts ─────────────────────────────────────────

function collectAllFiles(artifacts: ModuleArtifacts): ModuleFile[] {
  const files: ModuleFile[] = [];

  if (artifacts.uiPage) files.push(artifacts.uiPage);
  files.push(...artifacts.uiComponents);
  files.push(...artifacts.apiRoutes);
  if (artifacts.dbMigration) files.push(artifacts.dbMigration);
  files.push(artifacts.registryEntry);
  files.push(artifacts.readme);

  return files;
}

// ── Main Commit Function ──────────────────────────────────────────────────────

export async function commitModule(
  req: ModuleRequest,
  artifacts: ModuleArtifacts,
  version: string
): Promise<CommitRecord> {
  const octokit = getOctokit();
  const files = collectAllFiles(artifacts);

  if (files.length === 0) {
    throw new Error('[Writer] No files to commit');
  }

  // 1. Get current HEAD commit SHA
  const refRes = await octokit.git.getRef({
    owner: REPO_OWNER,
    repo: REPO_NAME,
    ref: `heads/${DEFAULT_BRANCH}`,
  });
  const headSHA = refRes.data.object.sha;

  // 2. Get the tree SHA from HEAD commit
  const headCommit = await octokit.git.getCommit({
    owner: REPO_OWNER,
    repo: REPO_NAME,
    commit_sha: headSHA,
  });
  const baseTreeSHA = headCommit.data.tree.sha;

  // 3. Create blobs + build tree
  console.info(`[Writer] Creating ${files.length} blobs for ${req.slug}...`);
  const treeEntries = await buildTreeEntries(octokit, files);

  // 4. Create new tree on top of base
  const newTree = await octokit.git.createTree({
    owner: REPO_OWNER,
    repo: REPO_NAME,
    base_tree: baseTreeSHA,
    tree: treeEntries,
  });

  // 5. Create the commit
  const commitMessage = [
    `feat(module-factory): add ${req.name} module [v${version}]`,
    '',
    `Family: ${req.family}`,
    `Types: ${req.types.join(', ')}`,
    `Credits: ${req.creditsPerUse}/use | Min plan: ${req.minPlan}`,
    `Files: ${files.map((f) => f.path).join(', ')}`,
    '',
    `Generated by Javari Module Factory v2.0`,
    `Timestamp: ${new Date().toISOString()}`,
  ].join('\n');

  const newCommit = await octokit.git.createCommit({
    owner: REPO_OWNER,
    repo: REPO_NAME,
    message: commitMessage,
    tree: newTree.data.sha,
    parents: [headSHA],
  });

  // 6. Update the branch ref
  await octokit.git.updateRef({
    owner: REPO_OWNER,
    repo: REPO_NAME,
    ref: `heads/${DEFAULT_BRANCH}`,
    sha: newCommit.data.sha,
    force: false,
  });

  console.info(`[Writer] Committed ${files.length} files: ${newCommit.data.sha.slice(0, 10)}`);

  return {
    sha: newCommit.data.sha,
    url: newCommit.data.html_url ?? `https://github.com/${REPO_OWNER}/${REPO_NAME}/commit/${newCommit.data.sha}`,
    branch: DEFAULT_BRANCH,
    filesCommitted: files.map((f) => f.path),
    message: commitMessage,
    timestamp: new Date().toISOString(),
  };
}

// ── Trigger Vercel Deploy ─────────────────────────────────────────────────────

export interface VercelDeployOptions {
  projectId: string;
  teamId: string;
  branch?: string;
}

export async function triggerVercelDeploy(opts: VercelDeployOptions): Promise<{
  deploymentId: string;
  url: string;
  previewUrl: string;
  triggeredAt: string;
  status: 'triggered';
}> {
  const vercelToken = vault.get('vercel');
  if (!vercelToken) throw new Error('[Writer] VERCEL_TOKEN not found in vault');

  const VERCEL_TOKEN = vercelToken;
  const PROJECT_ID = opts.projectId || process.env.VERCEL_PROJECT_ID || 'prj_zxjzE2qvMWFWqV0AspGvago6aPV5';
  const TEAM_ID = opts.teamId || process.env.VERCEL_TEAM_ID || 'team_Z0yef7NlFu1coCJWz8UmUdI5';

  // Vercel auto-deploys on push to main — but we can also trigger via API
  const res = await fetch(
    `https://api.vercel.com/v13/deployments?teamId=${TEAM_ID}`,
    {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${VERCEL_TOKEN}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        name: REPO_NAME,
        gitSource: {
          type: 'github',
          repo: `${REPO_OWNER}/${REPO_NAME}`,
          ref: opts.branch ?? DEFAULT_BRANCH,
        },
        projectSettings: {
          framework: 'nextjs',
        },
      }),
    }
  );

  if (!res.ok) {
    const errText = await res.text();
    // Vercel often auto-triggers on git push — this is non-fatal
    console.warn(`[Writer] Vercel deploy API returned ${res.status}: ${errText.slice(0, 200)}`);
    // Return synthetic record — actual deploy triggered by git push
    return {
      deploymentId: `auto-${Date.now()}`,
      url: `https://craudiovizai.com`,
      previewUrl: `https://javari.vercel.app`,
      triggeredAt: new Date().toISOString(),
      status: 'triggered',
    };
  }

  const data = await res.json() as {
    id?: string;
    url?: string;
    alias?: string[];
  };

  return {
    deploymentId: data.id ?? `deploy-${Date.now()}`,
    url: data.url ? `https://${data.url}` : 'https://craudiovizai.com',
    previewUrl: data.alias?.[0] ? `https://${data.alias[0]}` : `https://javari.vercel.app`,
    triggeredAt: new Date().toISOString(),
    status: 'triggered',
  };
}

// ── Register Module in Supabase ───────────────────────────────────────────────

export async function registerModuleInSupabase(
  req: ModuleRequest,
  artifacts: ModuleArtifacts,
  version: string,
  commitSha?: string,
  deployUrl?: string
): Promise<void> {
  const supaUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supaKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

  if (!supaUrl || !supaKey) {
    console.warn('[Writer] Supabase not configured — skipping registry');
    return;
  }

  const now = new Date().toISOString();
  const entry = {
    slug: req.slug,
    name: req.name,
    description: req.description,
    family: req.family,
    types: req.types,
    credits_per_use: req.creditsPerUse,
    min_plan: req.minPlan,
    status: 'ready',
    version,
    ui_path: artifacts.uiPage?.path ?? null,
    api_path: artifacts.apiRoutes[0]?.path ?? null,
    db_table: artifacts.dbMigration ? `${req.family.replace(/-/g, '_')}_${req.slug.replace(/-/g, '_')}_usage` : null,
    commit_sha: commitSha ?? null,
    deploy_url: deployUrl ?? null,
    generated_at: now,
    updated_at: now,
  };

  await fetch(`${supaUrl}/rest/v1/javari_modules`, {
    method: 'POST',
    headers: {
      apikey: supaKey,
      Authorization: `Bearer ${supaKey}`,
      'Content-Type': 'application/json',
      Prefer: 'resolution=merge-duplicates,return=minimal',
    },
    body: JSON.stringify(entry),
  });

  console.info(`[Writer] Module ${req.slug} registered in Supabase`);
}
