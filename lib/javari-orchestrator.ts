// lib/javari-orchestrator.ts
// Javari AI Autonomous Deployment Orchestrator
// Coordinates GitHub, Vercel, and File System MCP servers

import axios, { AxiosError } from 'axios';

const GITHUB_MCP_URL = process.env.GITHUB_MCP_URL;
const VERCEL_MCP_URL = process.env.VERCEL_MCP_URL;
const FILESYSTEM_MCP_URL = process.env.FILESYSTEM_MCP_URL;
const MCP_API_KEY = process.env.MCP_API_KEY;
const GITHUB_ORG = process.env.GITHUB_ORG || 'CR-AudioViz-AI';

interface WorkflowStep {
  name: string;
  status: 'pending' | 'running' | 'success' | 'failed';
  startedAt?: string;
  completedAt?: string;
  error?: string;
  data?: any;
}

interface DeploymentWorkflow {
  id: string;
  status: 'running' | 'success' | 'failed' | 'rolled-back';
  steps: WorkflowStep[];
  artifacts: {
    repoUrl?: string;
    deploymentUrl?: string;
    commitSha?: string;
  };
  error?: {
    step: string;
    message: string;
    resolution?: string;
  };
  startedAt: string;
  completedAt?: string;
}

export class JavariOrchestrator {
  private mcpHeaders = {
    'x-api-key': MCP_API_KEY,
    'Content-Type': 'application/json',
  };

  async deployApplication(config: {
    appName: string;
    files: Array<{ path: string; content: string }>;
    userId: string;
  }): Promise<DeploymentWorkflow> {
    const workflowId = `wf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const workflow: DeploymentWorkflow = {
      id: workflowId,
      status: 'running',
      steps: [
        { name: 'create_workspace', status: 'pending' },
        { name: 'write_files', status: 'pending' },
        { name: 'validate_typescript', status: 'pending' },
        { name: 'create_repository', status: 'pending' },
        { name: 'commit_files', status: 'pending' },
        { name: 'deploy_to_vercel', status: 'pending' },
        { name: 'monitor_deployment', status: 'pending' },
        { name: 'verify_deployment', status: 'pending' },
        { name: 'cleanup_workspace', status: 'pending' },
      ],
      artifacts: {},
      startedAt: new Date().toISOString(),
    };

    try {
      // Step 1: Create workspace
      await this.executeStep(workflow, 0, async () => {
        const response = await axios.post(
          `${FILESYSTEM_MCP_URL}/api/workspace/create`,
          { workspaceId: workflowId },
          { headers: this.mcpHeaders }
        );
        return response.data;
      });

      // Step 2: Write files to workspace
      await this.executeStep(workflow, 1, async () => {
        for (const file of config.files) {
          await axios.post(
            `${FILESYSTEM_MCP_URL}/api/files/create`,
            {
              workspaceId: workflowId,
              filePath: file.path,
              content: file.content,
            },
            { headers: this.mcpHeaders }
          );
        }
        return { filesWritten: config.files.length };
      });

      // Step 3: Validate TypeScript (if applicable)
      const hasTypeScript = config.files.some(f => f.path.endsWith('.ts') || f.path.endsWith('.tsx'));
      if (hasTypeScript) {
        await this.executeStep(workflow, 2, async () => {
          const response = await axios.post(
            `${FILESYSTEM_MCP_URL}/api/validate/typescript`,
            { workspaceId: workflowId },
            { headers: this.mcpHeaders }
          );
          return response.data;
        });
      } else {
        workflow.steps[2].status = 'success';
        workflow.steps[2].data = { skipped: true };
      }

      // Step 4: Create GitHub repository
      await this.executeStep(workflow, 3, async () => {
        const response = await axios.post(
          `${GITHUB_MCP_URL}/api/repos/create`,
          {
            name: config.appName,
            description: `Generated by Javari AI - ${new Date().toISOString()}`,
          },
          { headers: this.mcpHeaders }
        );
        workflow.artifacts.repoUrl = response.data.repository.html_url;
        return response.data;
      });

      // Step 5: Commit files to repository
      await this.executeStep(workflow, 4, async () => {
        const response = await axios.post(
          `${GITHUB_MCP_URL}/api/repos/${GITHUB_ORG}/${config.appName}/commit`,
          {
            files: config.files.map(f => ({
              path: f.path,
              content: f.content,
            })),
            message: 'Initial commit - Generated by Javari AI',
          },
          { headers: this.mcpHeaders }
        );
        workflow.artifacts.commitSha = response.data.commit.sha;
        return response.data;
      });

      // Step 6: Deploy to Vercel (preview mode)
      await this.executeStep(workflow, 5, async () => {
        const response = await axios.post(
          `${VERCEL_MCP_URL}/api/deploy`,
          {
            repoUrl: workflow.artifacts.repoUrl,
            projectName: config.appName,
          },
          { headers: this.mcpHeaders }
        );
        return response.data;
      });

      // Step 7: Monitor deployment
      await this.executeStep(workflow, 6, async () => {
        const deploymentId = workflow.steps[5].data?.deployment?.id;
        if (!deploymentId) throw new Error('No deployment ID from previous step');

        let attempts = 0;
        const maxAttempts = 60; // 5 minutes (5 second intervals)

        while (attempts < maxAttempts) {
          const response = await axios.get(
            `${VERCEL_MCP_URL}/api/deploy/${deploymentId}/status`,
            { headers: this.mcpHeaders }
          );

          const status = response.data.deployment.status;

          if (status === 'READY') {
            workflow.artifacts.deploymentUrl = response.data.deployment.url;
            return response.data;
          }

          if (status === 'ERROR' || status === 'CANCELED') {
            throw new Error(`Deployment ${status.toLowerCase()}: ${response.data.deployment.error || 'Unknown error'}`);
          }

          await new Promise(resolve => setTimeout(resolve, 5000));
          attempts++;
        }

        throw new Error('Deployment timeout - exceeded 5 minutes');
      });

      // Step 8: Verify deployment (HTTP check)
      await this.executeStep(workflow, 7, async () => {
        const url = workflow.artifacts.deploymentUrl;
        if (!url) throw new Error('No deployment URL');

        const response = await axios.get(`https://${url}`, {
          timeout: 10000,
          validateStatus: () => true,
        });

        if (response.status !== 200) {
          throw new Error(`Deployment verification failed: HTTP ${response.status}`);
        }

        return { verified: true, statusCode: response.status };
      });

      // Step 9: Cleanup workspace
      await this.executeStep(workflow, 8, async () => {
        const response = await axios.delete(
          `${FILESYSTEM_MCP_URL}/api/workspace/clean`,
          {
            headers: this.mcpHeaders,
            data: { workspaceId: workflowId },
          }
        );
        return response.data;
      });

      // Workflow complete
      workflow.status = 'success';
      workflow.completedAt = new Date().toISOString();

    } catch (error) {
      workflow.status = 'failed';
      workflow.completedAt = new Date().toISOString();

      const axiosError = error as AxiosError;
      const errorMessage = axiosError.response?.data || axiosError.message || 'Unknown error';

      // Find the current running step
      const failedStepIndex = workflow.steps.findIndex(s => s.status === 'running');
      if (failedStepIndex >= 0) {
        workflow.steps[failedStepIndex].status = 'failed';
        workflow.steps[failedStepIndex].error = String(errorMessage);
        workflow.steps[failedStepIndex].completedAt = new Date().toISOString();

        workflow.error = {
          step: workflow.steps[failedStepIndex].name,
          message: String(errorMessage),
          resolution: this.getErrorResolution(workflow.steps[failedStepIndex].name, String(errorMessage)),
        };
      }

      // Attempt cleanup even on failure
      try {
        await axios.delete(
          `${FILESYSTEM_MCP_URL}/api/workspace/clean`,
          {
            headers: this.mcpHeaders,
            data: { workspaceId: workflowId },
          }
        );
      } catch {
        // Ignore cleanup errors
      }
    }

    return workflow;
  }

  private async executeStep(
    workflow: DeploymentWorkflow,
    stepIndex: number,
    action: () => Promise<any>
  ): Promise<void> {
    const step = workflow.steps[stepIndex];
    step.status = 'running';
    step.startedAt = new Date().toISOString();

    try {
      const result = await action();
      step.status = 'success';
      step.data = result;
      step.completedAt = new Date().toISOString();
    } catch (error) {
      step.status = 'failed';
      step.error = error instanceof Error ? error.message : String(error);
      step.completedAt = new Date().toISOString();
      throw error;
    }
  }

  private getErrorResolution(stepName: string, errorMessage: string): string {
    const resolutions: Record<string, string> = {
      create_workspace: 'Check File System MCP server is running and accessible',
      write_files: 'Verify file paths are valid and content is properly formatted',
      validate_typescript: 'Review TypeScript errors and fix code issues',
      create_repository: 'Check GitHub MCP server and verify organization permissions',
      commit_files: 'Ensure repository exists and files are properly formatted',
      deploy_to_vercel: 'Verify Vercel MCP server is running and has valid credentials',
      monitor_deployment: 'Check Vercel deployment logs for build errors',
      verify_deployment: 'Verify the deployed application is responding correctly',
      cleanup_workspace: 'Workspace cleanup failed but deployment may still be successful',
    };

    return resolutions[stepName] || 'Check MCP server logs for detailed error information';
  }

  async getWorkflowStatus(workflowId: string): Promise<DeploymentWorkflow | null> {
    // This would typically query Supabase workflow_executions table
    // For now, returning null - implementation depends on Supabase integration
    return null;
  }

  async cancelWorkflow(workflowId: string): Promise<void> {
    // This would cancel any running deployments
    // Implementation depends on tracking active workflows
    throw new Error('Not implemented');
  }
}

export default JavariOrchestrator;
